/* 
* Copyright 2014 Friedemann Zenke
*
* This file is part of Auryn, a simulation package for plastic
* spiking neural networks.
* 
* Auryn is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* Auryn is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with Auryn.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef WEIGHTMONITOR_H_
#define WEIGHTMONITOR_H_

#include "auryn_definitions.h"
#include "Monitor.h"
#include "System.h"
#include "SparseConnection.h"
#include <fstream>
#include <iomanip>

using namespace std;


enum RecordingMode { SINGLE, DATARANGE, ELEMENTLIST };
enum PatternMode { ALLTOALL, ASSEMBLIES_ONLY};

/*! \brief Monitors the evolution of a single or a set of weights 
 *
 * This class can be used to perform online monitoring  synaptic weights. By default it records a single synapse at position i,j
 * in the designated Connection. This behaviour can be changed by specifying recordingtype=DATARANGE. The parameters i,j are then 
 * interpreted as range i..j in the data array of the source Connection. Note that in DATARANGE mode the Monitor could in principle
 * also monitor zero connections. However in SINGLE it records only non-zero elements.
 * \param system The obvious system class
 * \param source The connection object to record from
 * \param i Parameter i (either row position of synapse in WeightMatrix or start index in data array depending on mode)
 * \param j Parameter j (either col position of synapse in WeightMatrix or stop index in data array depending on mode) 
 * \param filename The file to record to
 * \param interval The sampling interval in simulation interval (1s  default) 
 */ 
class WeightMonitor : protected Monitor
{
protected:
	SparseConnection * src;
	ForwardMatrix * mat;
	RecordingMode recordingmode;
	NeuronID elem_i;
	NeuronID elem_j;
	AurynTime ssize;
	vector<AurynWeight*> * element_list;
	/*! Vector storing all the patterns */
	vector<type_pattern> * patterns;
	void init(SparseConnection * source, NeuronID i, NeuronID j, string filename, AurynTime interval);
	
public:
	WeightMonitor(SparseConnection * source, string filename, AurynDouble interval=1);
	WeightMonitor(SparseConnection * source, ForwardMatrix * m, string filename, AurynDouble interval=1);
	WeightMonitor(SparseConnection * source, NeuronID i, NeuronID j, string filename, AurynDouble interval=1, RecordingMode mode = SINGLE);
	virtual ~WeightMonitor();
	void propagate();

	void set_mat(ForwardMatrix * m);


	/*! Adds a single element identified by a pointer to the recording list. */
	void add_to_list( AurynWeight * ptr );
	/*! Adds a single element identified matrix coordinates (row,col) to the recording list. */
	void add_to_list( NeuronID i, NeuronID j );
	/*! Adds a list vector<neuron_pair> vec the the recording list. Such a list
	 * can for instance be generated by a SparseConnection with the get_block 
	 * function. 
	 */
	void add_to_list( vector<neuron_pair> vec , string label = "");
	
	/*! Adds number of elements to the recording list that are equally spaced in the 
	 * data vector of SimpleMatrix. This effectively corresponds to number random 
	 * elements if a random matrix is used. 
	 */
	void add_equally_spaced( NeuronID number );

	/*! Adds connections inside a pattern and between patterns. Since such lists
	 * can become large quickly the amount of patterns and connections for each
	 * pattern to be monitored can be limited by maxcon and maxpat.
	 * \param filename The filename of the .pat file
	 * \param maxcon maximum number of connection per pattern or between patterns
	 * \param maxpat maximum number of patterns to read from .pat file
	 * \param patmod ALLTOALL means from all patterns to all patterns. ASSEMBLIES_ONLY
	 *		only adds connections inside single patterns.
	 */
	void load_pattern_connections(string filename, int maxcon = 5, int maxpat = 10, PatternMode patmod = ALLTOALL);
	void load_data_range(NeuronID i, NeuronID j);
};

#endif /*WEIGHTMONITOR_H_*/
